myPHPcms High Level Design
==========================

Version 0.1
-----------

Author: Phil Lee

EXECUTIVE SUMMARY

Blah blah !


1.0	SCOPE

The document details the design of the myPHPcms at the highest level.
The Functional Specification document is a list of 'must-have'
features or behaviours organised into modules and this document 
outlines how these features will actually be implemented.

No code descriptions can be found in this document.  Details of the
actual code can be found in the individual Module Detailed Design
document.  Instead, a list of scripts, their relationship with other
modules and justification for any decisions taken during the design 
process are presented.  Additionally a list of database tables and
their purposes can also be found within this document.

This document is designed to be used in conjunction with the Functional
Specification document when creating the Module Detailed Design 
documents.  It can also be used as the basis of the technical 
documentation.


2.0	REFERENCE DOCUMENTATION

The latest version of the myPHPcms Functional Specification which can
be found in the 'doc' directory.


3.0	SOFTWARE ARCHITECTURE

The whole of myPHPcms is designed to be modular so that the web-site
administrator can choose to install as much or as little functionality
as is required.  This will be possible through the development of a 
core of functionality that can have additional modules 'plugged in'
either at installation time or later in the life of the web-site.

The following is a list of software modules that are either included 
within myPHPcms by default or which may be installed separately.

CORE MODULES			OPTIONAL MODULES
* HTML library			* User comments
* Caching module		* User forums
* Templating module		* Links management
* Access logging module		* User polls
* User sign-up and login	* Download manager
* Site administration		* Site search module
* Channel administration	* Mailing list manager
* Core CMS functions		* Banner advert manager
* Diagnostics modules

In general a module will consist of a number of files each of which 
will carry out a specific task.  A module will also include files that
allow the administrator of the channel or site to administer the module.

An outline of the directory structure is shown below:

	$site_root		contains the bulk of the scripts for the
	|			site
    	|
    	+-admin			contains configuration & administrator
				scripts
    		+-libs		contains admin-only libraries
    		+-templates	contains admin-only template definitions
    	+-doc			contains usage and design documentation
    	+-libs			contains the actual script libraries for
				users
    	+-sql			contains the fragments of SQL necessary to 
				build the tables for the various modules
    	+-tests			contains test scripts to test the modules

It is antipcated that all scripts will be written in PHP.  There may be
a few HTML files together with a number of plain text files containing
configuration data for the site.

Security of the scripts will be the responsbility of both the web server
and also the scripts themselves.  All scripts will check that the user
has the appropriate authority to execute them (in the case of the forum
script only logged in users may post articles).  In addition the web
server built-in permissions will be used to discriminate between the
regular site visitors and the administrators through the use of the
.htaccess file and .htpasswd files.


4.0	Software Modules

Blah blah !

4.1	HTML library

Blah blah !

4.2	Site administration module

* Default user is overall site admin called 'god'.  No password by
  default
* All user data stored in user table
* User profiles eg editor etc stored in another table
* Users can register themselves by only site admin can promote users to
  author, editor etc roles

4.3	Channel administration module

Blah blah !

4.4	Diagnostics module

Blah blah !

4.5	Installation script

The whole process of using myPHPcms should be as easy as possible.  
This should start from the moment that the product is downloaded and
the component files are unpacked into the web server directory.  

The complete archive file that is downloaded by the user should contain
the directory structure defined in section 3.0 Software Architecture
with the appropriate permissions on the files and directories.  However
in this state neither the database will exist nor will the administrator
scripts be protected from unauthorised users.

To counter these problems a number of steps need to be taken and these
should be automated through the use of an install script.  It is likely
at some point that an existing version of myPHPcms will be upgraded to
a newer version.  In this instance an upgrade script should be run that
will make the necessary modifications to the databases and scripts.

All of the setup scripts should reside in the admin directory.  Since 
these scripts will be executed before any other components of myPHPcms
is installed they will have to be entirely self-contained.  They cannot
make calls to the templating system or the user authentication system.  
It is possible, however, that they will be able to call a directly 
included setup library contained within a sub-directory of the admin 
directory.

To prevent an upgrade being performed on a database that has not yet
been installed the installation script should look for the presence of
a flag.  If found then this will be interpreted as a properly 
configured installation and so an upgrade will be assumed.  Otherwise a
new installation will assumed.

Add:	Tasks that script must perform (1) define master admin (2) enter
	details into MySQL database (3) add to .htaccess and .htpasswd
	files in $SITE_ROOT/admin/master (4) invites user to log back in

4.6	CMS module

4.6.1	Main page display script

When run this script checks for the presence of the cookie that 
indicates the user is registered on the site.  If the cookie is found,
then it retrieves the users name from the database and creates a 
temporary template contain the users name and a short welcome message.
Otherwise the temporary template contains a box for the user to log in 
or register.  The module then connects to the database, pulls out the 
latest story headlines and counts the number of comments for each 
story within the database.  Hyperlinks to the news stories are 
automatically embedded with the page HTML.  This data is then fed into 
the templating system in order to create the final HTML.

When the user clicks on the link to submit a news story the cookie that
indicates that they are a registered user should be checked.  If it 
cannot be found it would suggest that they are not a member or that the 
cookie has been deleted so they should be offered the option to 
register or sign-up.  Once logged in they are shown a form into which 
they can enter the story headline and the body of the story.  At any 
time they can preview the page as it will eventually appear.  Once 
submitted the story content and information (date, time, author) are 
entered into the database.

4.6.2	Story display script

When the user clicks on a news headline on the front page the story 
module connects to the database and pulls the headline and story 
content from the database.  It also connects to the database to 
retrieve the subjects of comments that users have posted.  The URL's 
of the page with the comment expanded to show it's full text are 
automatically embedded within the page.  All of this data is then 
passed to the templating system so that the page can be displayed in 
the users browser.

4.7	Access logging module

The design requirements for the Access Logging module specified in the
Functional Specification document can be divided into two main areas.
These are (1) data gathering and (2) data processing and reporting.
Both are described in more detail in this section.

4.7.1	Data gathering

The logging system must be capable of collecting data from both static
HTML pages as well as dynamic PHP pages.  This would allow the system 
to be applied to purely static HTML sites as well as dynamically 
created sites and also the hybrid - a dynamically generated cache of
static HTML pages.

These two scenarios require fundamentally different approaches to 
obtaining the data that we need.  Pages that are created dynamically 
from a database can simply log access to themselves by recording the 
fact into a table within the database.  Once the information to be 
logged has been determine this is quick and easy to do.

Purely static HTML pages are much more difficult to deal with since it
is likely that the server on which they are hosted may not be capable 
of executing server-side scripting languages.  As a result a rather
ingenious solution needs to be developed.

The solution chosen is to use a GIF image that is in fact a PHP script
that is hosted on a server that can execute PHP scripts.  This GIF 
image is called by the HTML file allowing access to the HTTP enviroment
variables which can then be logged in the database by the PHP script.
Once the data has been collected a transparent GIF image 1 pixel wide 
by 1 pixel high is returned to the browser.  To prevent caching of the
image (which would defeat this technique) a random value is attached to 
a variable which is sent in the URL that requests the GIF.  This will 
be carried out using Javascript.

Knowing which pages the user requested is useful but of even more use
is knowing the route through the website that the user takes.  In 
theory this information can be deduced from the IP address of user and
the page referrers.  However this is risky because if two users from
the same ISP browse the site simultaneously then their IP address will
appear to be the same.  As a result the logging system will confuse
their movements through the site.

A far better method would be to track the individual web-browsers and 
this can be done through the use of PHP sessions.  Any PHP script can
start a session so technically there is no reason why the pseudo-GIF 
image, which is in fact a PHP script, cannot be configured to start a
session and then place that into the database.

Knowing the the users are visiting the site and are navigating their 
way around it is useful but the final piece in the jigsaw would to find
out how long the pages take to load.  For the pure PHP pages this could 
be carried out by a total of two database INSERTS - one at the very top 
of the page and one at the very end.  By obtaining timestamps and 
calculating the difference the overall page load time could be 
determined.  The only drawback is that this would require two database
INSERTS.  An additional benefit of this approach is that cancelled 
pages could be detected because the second timestamp would not be 
present.

The same information should be available for HTML pages as well.  This
may require the use of two separate GIF files linked together by a 
common session identifier and page name.  This needs further 
investigation.

Having determine the pages that the users view, their viewing habits 
and amount of tolerance to slow loading pages, their preference for web
browsers should also be detected.  This can be done by obtaining the
browsers user agent and then parsing this.  Any user agents that
cannot be identified should be emailed to the master site administrator
for identification and upgrading of the system.  Since new browsers are 
released fairly frequently the browser detection code should be 
contained in a separate library so that it may be upgraded without 
having to take the entire system down.  

The user agents could be stored in a database but in order to minimise
the load on the database the decision has been taken to hard-code the
detection routine.

4.7.2	Data processing and reporting

Unlike some logging systems, this one will only query the database when
requested to by the channel or master administrator.  This allows the
latest results to be used and prevents decisions being made on out of
date data.

In order to provide maximum flexibility all queries will be able to be
run over various time periods ranging from 'this day' to 'this week' to
'this year'.

Where external data is required for analysis, for example where the host
name is resolved via a reverse DNS lookup, then this data will be cached
in order to speed up subsequent queries.

Possible queries that could be run against the database range from the 
very simple such as "total number of page views since start of logging"
to "show the path through the site of user number 3 today".  Exactly 
how these queries will be constructed, processed and reported can be
found in the Access Logging Detailed Design document.

All output from the access logging module will be created as a local
template in the templating system through the use of the HTML library.

4.8	Templating module

To minimise the number of templates for a given number of pages any 
template should be capable of being made up of other templates.  This 
would allow the re-use of existing templates if small templates existed
for common page elements such as headers or footers.  This could be 
achieved by assigning each template a unique number and storing the 
relationships between the parent template and child templates that 
comprise it.

* Templates for admin engine have channel_id=0
* All public channel_id start at 1

4.9	User sign-up and log-in module

Since the username is the users email address this will need to be
validated.  This could be performed by a regular expression match on
the supplied email address.  If it fails then the user will be asked to
re-enter their email address.  If successful their choice of password
will be asked for again for confirmation - it will then be checked to 
see that it contains enough characters.  If it does not then it will 
requested again.  If successful the user will be added to the database
but marked as inactive.  An email will then be sent to the supplied 
email address which will open a custom URL when the user clicks on it 
thus activating the account.  The username and a unique id are then 
stored in the users browser as a cookie in order to prevent them from 
having to log in again.

Task:	Look at PHPBuilder article

4.10	Page caching module

* Set options in each file whether to cache and if so where to put the
  file afterwards.  Also et age of cached file.  When file loads, check
  to see if should be cached, if so check for presnce of cached file.
  If exists and not too old then use it else create more up to date
  version.

4.11	Comments module

When the user clicks on a link to add a comment the cookie that 
indicates that are registered is checked.  If it cannot be found then 
the user is invited to register otherwise the user is presented with a 
form into which they can enter their comments.  At any time they can 
preview their contribution.  When they press submit the information that 
they have entered together with other information (date, time, author) 
is entered into the database.  The page is then recreated from the 
database and is displayed to the user.

4.12	Forums module

Blah blah !

4.13	Links manager module

Blah blah !

4.14	Polls module

* Should comprise of the following:
  polls.sql        - SQL code to create single table to store data
  poll_vote.php    - shows latest current poll and allows voting
  poll_show.php    - shows latest results
  poll_results.php - allows results of old polls to be searched for
                     and viewed
  admin_poll.php   - administration script to create/modify/delete
                     polls
* Must prevent user from voting in the same poll multiple times.  Can
  either be done using cookie or by logging their IP address (care !)
* Should provide graphical results but not use complex PHP features 
  like GD library as not all servers may support it.
  
4.15	Download manager module

Blah blah !

4.16	Site search module

Blah blah !

4.17	Events module

Blah blah !

4.18	Mailing list manager module

Blah blah !

4.19	Banner advert manager module

Blah blah !

4.20	User rating system

Blah blah !


5.0	DESIGN AND CODING

Blah blah !


6.0	SECURITY ISSUES

Insert brief bullet point summary of points contained in the Coding
Guidelines in this section.   


App A	Technical notes

Blah blah (if required)
