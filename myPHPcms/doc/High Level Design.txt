myPHPcms High Level Design
==========================

Version 0.1
-----------

Author: Phil Lee

EXECUTIVE SUMMARY

Blah blah !


1.0	SCOPE

The document details the design of the myPHPcms at the highest level.
The Functional Specification document is a list of 'must-have'
features or behaviours organised into modules and this document 
outlines how these features will actually be implemented.

No code descriptions can be found in this document.  Details of the
actual code can be found in the individual Module Detailed Design
document.  Instead, a list of scripts, their relationship with other
modules and justification for any decisions taken during the design 
process are presented.  Additionally a list of database tables and
their purposes can also be found within this document.

This document is designed to be used in conjunction with the Functional
Specification document when creating the Module Detailed Design 
documents.  It can also be used as the basis of the technical 
documentation.


2.0	REFERENCE DOCUMENTATION

The latest version of the myPHPcms Functional Specification which can
be found in the 'doc' directory.


3.0	SOFTWARE ARCHITECTURE

The whole of myPHPcms is designed to be modular so that the web-site
administrator can choose to install as much or as little functionality
as is required.  This will be possible through the development of a 
core of functionality that can have additional modules 'plugged in'
either at installation time or later in the life of the web-site.

The following is a list of software modules that are either included 
within myPHPcms by default or which may be installed separately.

CORE MODULES			OPTIONAL MODULES
* HTML library			* User comments
* Caching module		* User forums
* Templating module		* Links management
* Access logging module		* User polls
* User sign-up and login	* Download manager
* Site administration		* Site search module
* Channel administration	* Mailing list manager
* Core CMS functions		* Banner advert manager
* Diagnostics modules

In general a module will consist of a number of files each of which 
will carry out a specific task.  A module will also include files that
allow the administrator of the channel or site to administer the module.

An outline of the directory structure is shown below:

	$site_root		contains the bulk of the scripts for the
	|			site
    	|
    	+-admin			contains configuration & administrator
				scripts
    		+-libs		contains admin-only libraries
    		+-templates	contains admin-only template definitions
    	+-doc			contains usage and design documentation
    	+-libs			contains the actual script libraries for
				users
    	+-sql			contains the fragments of SQL necessary to 
				build the tables for the various modules
    	+-tests			contains test scripts to test the modules

It is antipcated that all scripts will be written in PHP.  There may be
a few HTML files together with a number of plain text files containing
configuration data for the site.

Security of the scripts will be the responsbility of both the web server
and also the scripts themselves.  All scripts will check that the user
has the appropriate authority to execute them (in the case of the forum
script only logged in users may post articles).  In addition the web
server built-in permissions will be used to discriminate between the
regular site visitors and the administrators through the use of the
.htaccess file and .htpasswd files.


4.0	Software Modules

Blah blah !

4.1	HTML library

Blah blah !

4.2	Site administration module

* Default user is overall site admin called 'god'.  No password by
  default
* All user data stored in user table
* User profiles eg editor etc stored in another table
* Users can register themselves by only site admin can promote users to
  author, editor etc roles

4.3	Channel administration module

Blah blah !

4.4	Diagnostics module

Blah blah !

4.5	Installation script

The whole process of using myPHPcms should be as easy as possible.  
This should start from the moment that the product is downloaded and
the component files are unpacked into the web server directory.  

The complete archive file that is downloaded by the user should contain
the directory structure defined in section 3.0 Software Architecture
with the appropriate permissions on the files and directories.  However
in this state neither the database will exist nor will the administrator
scripts be protected from unauthorised users.

To counter these problems a number of steps need to be taken and these
should be automated through the use of an install script.  It is likely
at some point that an existing version of myPHPcms will be upgraded to
a newer version.  In this instance an upgrade script should be run that
will make the necessary modifications to the databases and scripts.

All of the setup scripts should reside in the admin directory.  Since 
these scripts will be executed before any other components of myPHPcms
is installed they will have to be entirely self-contained.  They cannot
make calls to the templating system or the user authentication system.  
It is possible, however, that they will be able to call a directly 
included setup library contained within a sub-directory of the admin 
directory.

To prevent an upgrade being performed on a database that has not yet
been installed the installation script should look for the presence of
a flag.  If found then this will be interpreted as a properly 
configured installation and so an upgrade will be assumed.  Otherwise a
new installation will assumed.

Add:	Tasks that script must perform (1) define master admin (2) enter
	details into MySQL database (3) add to .htaccess and .htpasswd
	files in $SITE_ROOT/admin/master (4) invites user to log back in

4.6	CMS module

4.6.1	Main page display script

When run this script checks for the presence of the cookie that 
indicates the user is registered on the site.  If the cookie is found,
then it retrieves the users name from the database and creates a 
temporary template contain the users name and a short welcome message.
Otherwise the temporary template contains a box for the user to log in 
or register.  The module then connects to the database, pulls out the 
latest story headlines and counts the number of comments for each 
story within the database.  Hyperlinks to the news stories are 
automatically embedded with the page HTML.  This data is then fed into 
the templating system in order to create the final HTML.

When the user clicks on the link to submit a news story the cookie that
indicates that they are a registered user should be checked.  If it 
cannot be found it would suggest that they are not a member or that the 
cookie has been deleted so they should be offered the option to 
register or sign-up.  Once logged in they are shown a form into which 
they can enter the story headline and the body of the story.  At any 
time they can preview the page as it will eventually appear.  Once 
submitted the story content and information (date, time, author) are 
entered into the database.

4.6.2	Story display script

When the user clicks on a news headline on the front page the story 
module connects to the database and pulls the headline and story 
content from the database.  It also connects to the database to 
retrieve the subjects of comments that users have posted.  The URL's 
of the page with the comment expanded to show it's full text are 
automatically embedded within the page.  All of this data is then 
passed to the templating system so that the page can be displayed in 
the users browser.

4.7	Access logging module

The design requirements for the Access Logging module specified in the
Functiional Specification document can be divided into three main 
sections.  These are (1) data gathering, (2) data processing and 
reporting and (3) other administration tasks.

4.7.1	Data gathering

The logging system must be capable of collecting data from both static
HTML pages as well as dynamic PHP pages.  This would allow the system 
to be applied to purely static HTML sites as well as dynamically 
created sites and also the hybrid - a dynamically generated cache of
static HTML pages.

These two scenarios require fundamentally different approaches to 
obtaining the data that we need.  Pages that are created dynamically 
from a database can simply log access to themselves by recording the 
fact into a table within the database.  Once the information to be 
logged has been determine this is quick and easy to do.

Purely static HTML pages are much more difficult to deal with since it
is likely that the server on which they are hosted may not be capable 
of executing server-side scripting langauges.  As a result a rather
ingenious solution needs to be developed.

The solution chosen is to use a GIF image that is in fact a PHP script
that is hosted on a server that can execute PHP scripts.  This GIF 
image is called by the HTML file allowing access to the HTTP enviroment
variables which can then be logged in the database by the PHP script.
Once the data has been collected a transparent 1 pixel wide by 1 pixel 
high GIF image is returned to the browser.  To prevent caching of the
image which would defeat this technique a random value is attached to a
variable which is sent in the URL that requests the GIF.  This will be 
carried by using Javascript.

GIF or script placed at top of file shows that file was accessed but no
way of knowing if user waited for page to load or if they clicked cancel.
Could add second call at bottom of page - easy in PHP, could even time
page creation but not so easy in HTML.  How to do ?

Browser version, platform and OS identification -> lib for easy upgrade
Hard-coded identification rather than db search to speed up execution
Unknown UA emails to admin for identification and updating of libs

4.7.2	Data processing and reporting

Database queried by admin whenever statistics required to use latest results
Comprehensive reporting options and timescales available
Caching of reverse DNS lookups allows faster queries second time around

4.7.3	Other administration tasks

Channel_id is logged on each access so allowing data to be processed on channel
by channel basis by channel admins.  Master site admin can look at all
data.
4.8	Templating module

To minimise the number of templates for a given number of pages any 
template should be capable of being made up of other templates.  This 
would allow the re-use of existing templates if small templates existed
for common page elements such as headers or footers.  This could be 
achieved by assigning each template a unique number and storing the 
relationships between the parent template and child templates that 
comprise it.

* Templates for admin engine have channel_id=0
* All public channel_id start at 1

4.9	User sign-up and log-in module

Since the username is the users email address this will need to be
validated.  This could be performed by a regular expression match on
the supplied email address.  If it fails then the user will be asked to
re-enter their email address.  If successful their choice of password
will be asked for again for confirmation - it will then be checked to 
see that it contains enough characters.  If it does not then it will 
requested again.  If successful the user will be added to the database
but marked as inactive.  An email will then be sent to the supplied 
email address which will open a custom URL when the user clicks on it 
thus activating the account.  The username and a unique id are then 
stored in the users browser as a cookie in order to prevent them from 
having to log in again.

Task:	Look at PHPBuilder article

4.10	Page caching module

* Set options in each file whether to cache and if so where to put the
  file afterwards.  Also et age of cached file.  When file loads, check
  to see if should be cached, if so check for presnce of cached file.
  If exists and not too old then use it else create more up to date
  version.

4.11	Comments module

When the user clicks on a link to add a comment the cookie that 
indicates that are registered is checked.  If it cannot be found then 
the user is invited to register otherwise the user is presented with a 
form into which they can enter their comments.  At any time they can 
preview their contribution.  When they press submit the information that 
they have entered together with other information (date, time, author) 
is entered into the database.  The page is then recreated from the 
database and is displayed to the user.

4.12	Forums module

Blah blah !

4.13	Links manager module

Blah blah !

4.14	Polls module

* Should comprise of the following:
  polls.sql        - SQL code to create single table to store data
  poll_vote.php    - shows latest current poll and allows voting
  poll_show.php    - shows latest results
  poll_results.php - allows results of old polls to be searched for
                     and viewed
  admin_poll.php   - administration script to create/modify/delete
                     polls
* Must prevent user from voting in the same poll multiple times.  Can
  either be done using cookie or by logging their IP address (care !)
* Should provide graphical results but not use complex PHP features 
  like GD library as not all servers may support it.
  
4.15	Download manager module

Blah blah !

4.16	Site search module

Blah blah !

4.17	Events module

Blah blah !

4.18	Mailing list manager module

Blah blah !

4.19	Banner advert manager module

Blah blah !

4.20	User rating system

Blah blah !


5.0	DESIGN AND CODING

Blah blah !


6.0	SECURITY ISSUES

Insert brief bullet point summary of points contained in the Coding
Guidelines in this section.   


App A	Technical notes

Blah blah (if required)
